# Generated by Antigravity [Forge: Gemini 3.0] | Spec: [Architect: Opus 4.5]
"""Deep Researcher Streamlit Application.

A web interface for the local deep researcher using LangChain's deepagents framework.
Features real-time task tracking, step visualization, and quality monitoring.

Run with: streamlit run app.py --server.port 8508
"""

import streamlit as st
import os
import sys
import time
from datetime import datetime
from typing import Dict, Any, Optional
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Add current directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Use LangGraph-based agent (works reliably with Ollama)
from agent import get_agent, get_agent_config

# Page configuration
st.set_page_config(
    page_title="Deep Researcher v0.1",
    page_icon="üîç",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better UI
st.markdown("""
<style>
    .stProgress > div > div > div > div {
        background-color: #4CAF50;
    }
    .step-indicator {
        padding: 10px;
        border-radius: 5px;
        margin: 5px 0;
    }
    .step-current {
        background-color: #2196F3;
        color: white;
    }
    .step-complete {
        background-color: #4CAF50;
        color: white;
    }
    .step-pending {
        background-color: #9E9E9E;
        color: white;
    }
    .warning-banner {
        background-color: #FF9800;
        color: white;
        padding: 15px;
        border-radius: 5px;
        margin: 10px 0;
    }
</style>
""", unsafe_allow_html=True)


def initialize_session_state():
    """Initialize all session state variables."""
    if "messages" not in st.session_state:
        st.session_state.messages = []
    
    if "current_phase" not in st.session_state:
        st.session_state.current_phase = "input"  # input, research, complete
    
    if "research_query" not in st.session_state:
        st.session_state.research_query = None
    
    if "todos" not in st.session_state:
        st.session_state.todos = []
    
    if "current_step" not in st.session_state:
        st.session_state.current_step = None
    
    if "step_history" not in st.session_state:
        st.session_state.step_history = []
    
    if "iteration_count" not in st.session_state:
        st.session_state.iteration_count = 0
    
    if "max_iterations_reached" not in st.session_state:
        st.session_state.max_iterations_reached = False
    
    if "final_report" not in st.session_state:
        st.session_state.final_report = None
    
    if "agent_files" not in st.session_state:
        st.session_state.agent_files = {}
    
    if "subagent_activity" not in st.session_state:
        st.session_state.subagent_activity = []
    
    if "research_steps" not in st.session_state:
        st.session_state.research_steps = []  # Store detailed research steps for display


def render_sidebar():
    """Render the sidebar with configuration and debug info."""
    with st.sidebar:
        st.title("‚öôÔ∏è Configuration")
        
        config = get_agent_config()
        
        st.subheader("Model Settings")
        st.info(f"**Model:** {config['model']}")
        st.caption(f"Base URL: {config['base_url']}")
        
        st.divider()
        
        st.subheader("Agent Limits")
        st.metric("Max Concurrent Sub-Agents", config['max_concurrent_research_units'])
        st.metric("Max Research Iterations", config['max_researcher_iterations'])
        st.metric("Recursion Limit", config['recursion_limit'])
        
        st.divider()
        
        st.subheader("Current Session")
        st.metric("Phase", st.session_state.current_phase.upper())
        st.metric("Iteration Count", st.session_state.iteration_count)
        
        if st.session_state.max_iterations_reached:
            st.warning("‚ö†Ô∏è Max iterations reached!")
        
        st.divider()
        
        # Debug section
        if st.checkbox("üîß Show Debug Info"):
            st.json({
                "todos": st.session_state.todos,
                "current_step": st.session_state.current_step,
                "step_history_count": len(st.session_state.step_history),
                "subagent_activity_count": len(st.session_state.subagent_activity),
                "agent_files": list(st.session_state.agent_files.keys()),
            })
        
        if st.button("üîÑ Reset Session"):
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.rerun()




def render_input_phase():
    """Render the query input phase."""
    st.markdown("Ask any research question and the deep agent will analyze, research, and synthesize a comprehensive report.")
    
    # Query input
    query = st.chat_input("What would you like to research?")
    
    if query:
        st.session_state.research_query = query
        st.session_state.messages.append({"role": "user", "content": query})
        st.session_state.current_phase = "research"
        st.rerun()
    
    # Display previous messages if any
    for msg in st.session_state.messages:
        with st.chat_message(msg["role"]):
            st.markdown(msg["content"])


def process_agent_event(event: Dict[str, Any]):
    """Process a streaming event from the agent and update UI state."""
    for key, value in event.items():
        # Track todos
        if key == "write_todos" or "todos" in str(value).lower():
            if isinstance(value, dict) and "todos" in value:
                st.session_state.todos = value["todos"]
        
        # Track file writes
        if key == "write_file" or "file" in str(key).lower():
            if isinstance(value, dict):
                filename = value.get("filename", value.get("path", "unknown"))
                content = value.get("content", "")
                st.session_state.agent_files[filename] = content
                
                # Check for final report
                if "final_report" in filename.lower():
                    st.session_state.final_report = content
        
        # Track sub-agent spawning
        if key == "task" or "subagent" in str(key).lower():
            st.session_state.subagent_activity.append({
                "agent": value.get("agent_name", "research-agent"),
                "action": "spawned",
                "query": str(value.get("input", ""))[:200],
                "timestamp": datetime.now().isoformat(),
            })
        
        # Update current step
        st.session_state.step_history.append(st.session_state.current_step or {})
        st.session_state.current_step = {
            "name": key,
            "description": str(value)[:100] if value else "",
            "timestamp": datetime.now().isoformat(),
        }
        
        # Track iterations
        st.session_state.iteration_count += 1
        
        # Check max iterations
        config = get_agent_config()
        max_iter = config["recursion_limit"]
        if st.session_state.iteration_count >= max_iter:
            st.session_state.max_iterations_reached = True


def render_research_phase():
    """Render the research execution phase - auto-starts research immediately."""
    # Auto-start research immediately (no button needed)
    run_research()


def run_research():
    """Execute the deep research agent."""
    agent = get_agent()
    query = st.session_state.research_query
    config = get_agent_config()
    
    with st.status(f"üîç Researching: {query}", expanded=True) as status:
        st.write(f"‚è≥ Using model: **{config['model']}** (may take 30-60 seconds per step)")
        
        # Create placeholders for live updates
        progress_placeholder = st.empty()
        stats_placeholder = st.empty()
        event_log = st.expander("üìä Event Log (Debug)", expanded=False)
        content_display = st.empty()
        
        # Initial state matching AgentState TypedDict
        initial_state = {
            "messages": [("human", query)],
            "research_findings": [],
            "iteration_count": 0
        }
        
        max_retries = 3
        retry_count = 0
        search_count = 0
        think_count = 0
        
        # Auto-generate initial task list
        st.session_state.todos = [
            {"title": "Analyze research question", "status": "in_progress"},
            {"title": "Search for information", "status": "pending"},
            {"title": "Reflect on findings", "status": "pending"},
            {"title": "Synthesize final answer", "status": "pending"},
        ]
        
        while retry_count < max_retries:
            try:
                event_count = 0
                all_content = []  # Collect all content for final report
                search_results = []  # Track search results
                final_answer = None  # Track the final answer specifically
                research_steps = []  # Track detailed research steps
                
                # Stream agent execution
                for event in agent.stream(initial_state):
                    event_count += 1
                    
                    # Log all events for debugging
                    with event_log:
                        st.write(f"Event {event_count}: {list(event.keys())}")
                    
                    # Process different event types
                    for key, value in event.items():
                        # Update progress display
                        progress_placeholder.info(f"üîÑ Step {event_count}: {key}")
                        
                        # Handle agent node output
                        if key == "agent" and isinstance(value, dict):
                            messages = value.get("messages", [])
                            for msg in messages:
                                # Capture content for final report
                                if hasattr(msg, 'content') and msg.content:
                                    content = str(msg.content)
                                    all_content.append(content)
                                    
                                    # FALLBACK: Try to parse various text output formats as final answer
                                    # Some models output text instead of making proper tool calls
                                    # Always try to extract and keep the longest/best answer
                                    extracted = None
                                    
                                    # Try JSON format: {"answer": "..."}
                                    if '"answer"' in content:
                                        try:
                                            import json
                                            parsed = json.loads(content)
                                            if isinstance(parsed, dict) and 'answer' in parsed:
                                                extracted = parsed['answer']
                                        except (json.JSONDecodeError, TypeError):
                                            pass
                                    
                                    # Try text format: - Tool: submit_final_answer\n- Arguments:\n  - answer: ...
                                    if extracted is None and 'submit_final_answer' in content and 'answer:' in content:
                                        try:
                                            import re
                                            # Match various formats the model might use
                                            match = re.search(r'answer:\s*\*?\*?(.+?)(?:\n\s*-\s*completed_tasks:|$)', content, re.DOTALL | re.IGNORECASE)
                                            if match:
                                                extracted = match.group(1).strip().strip('"\'*')
                                        except Exception:
                                            pass
                                    
                                    # Try markdown format: contains ### or ## headings and has substantial content
                                    if extracted is None and ('###' in content or '## ' in content) and len(content) > 300:
                                        extracted = content.strip()
                                    
                                    # Keep the longest extracted answer (better quality)
                                    if extracted and len(extracted) > 200:
                                        if final_answer is None or len(extracted) > len(final_answer):
                                            final_answer = extracted
                                            st.write(f"üìù Captured answer ({len(extracted)} chars)")
                                            st.session_state.todos[3]["status"] = "in_progress"
                                    
                                    # Update task: analyzing complete
                                    if st.session_state.todos[0]["status"] == "in_progress":
                                        st.session_state.todos[0]["status"] = "complete"
                                
                                if hasattr(msg, 'tool_calls') and msg.tool_calls:
                                    for tc in msg.tool_calls:
                                        tool_name = tc.get('name', 'unknown')
                                        tool_args = tc.get('args', {})
                                        
                                        # Track tavily search
                                        if tool_name == "tavily_search":
                                            search_count += 1
                                            search_query = tool_args.get('query', '')
                                            st.write(f"üîç Search #{search_count}: {search_query}")
                                            st.session_state.todos[1]["status"] = "in_progress"
                                            research_steps.append({
                                                "type": "search",
                                                "step": event_count,
                                                "query": search_query,
                                                "result": None  # Will be filled by tool result
                                            })
                                        
                                        # Track think tool
                                        if tool_name == "think_tool":
                                            think_count += 1
                                            reflection = tool_args.get('reflection', '')
                                            st.write(f"üß† Think #{think_count}: {reflection[:200]}...")
                                            st.session_state.todos[2]["status"] = "in_progress"
                                            research_steps.append({
                                                "type": "reflection",
                                                "step": event_count,
                                                "content": reflection
                                            })
                                        
                                        # Track submit_final_answer - capture the answer even if rejected
                                        if tool_name == "submit_final_answer":
                                            st.write(f"üìù Submitting final answer...")
                                            st.session_state.todos[3]["status"] = "in_progress"
                                            # Capture the submitted answer as a fallback
                                            submitted_answer = tool_args.get('answer', '')
                                            if submitted_answer and (final_answer is None or len(submitted_answer) > len(final_answer or '')):
                                                final_answer = submitted_answer
                                
                                # Update stats
                                stats_placeholder.info(f"üìä Searches: {search_count} | Reflections: {think_count} | Events: {event_count}")
                        
                        # Handle tools node output
                        if key == "tools" and isinstance(value, dict):
                            messages = value.get("messages", [])
                            for msg in messages:
                                if hasattr(msg, 'content') and msg.content:
                                    tool_result = str(msg.content)
                                    
                                    # Check if this is the accepted final answer
                                    if 'FINAL_ANSWER_ACCEPTED' in tool_result:
                                        st.success("‚úÖ Final answer accepted!")
                                        # Extract the answer from the tool result
                                        if '---ANSWER---' in tool_result:
                                            final_answer = tool_result.split('---ANSWER---')[1].strip()
                                            content_display.markdown(f"### üìù Final Answer\n\n{final_answer[:2000]}...")
                                        else:
                                            final_answer = tool_result
                                        st.session_state.todos[3]["status"] = "complete"
                                    elif 'SUBMISSION_REJECTED' in tool_result:
                                        st.warning(f"‚ö†Ô∏è Submission rejected: {tool_result[:200]}...")
                                    elif 'Reflection recorded:' in tool_result:
                                        # This is a think_tool result, already tracked
                                        pass
                                    else:
                                        # This is likely a search result - attach to last search step
                                        content_preview = tool_result[:200]
                                        st.write(f"üìÑ Result: {content_preview}...")
                                        # Update the last search step with its result
                                        for step in reversed(research_steps):
                                            if step["type"] == "search" and step["result"] is None:
                                                step["result"] = tool_result
                                                break
                                    
                                    search_results.append(tool_result)
                        
                        # Update step tracking
                        st.session_state.step_history.append(st.session_state.current_step or {})
                        st.session_state.current_step = {
                            "name": key,
                            "description": str(value)[:100] if value else "",
                            "timestamp": datetime.now().isoformat(),
                        }
                        st.session_state.iteration_count += 1
                    
                    # Check max iterations
                    if st.session_state.iteration_count >= config["recursion_limit"]:
                        st.session_state.max_iterations_reached = True
                        st.warning("Maximum iterations reached, stopping...")
                        break
                
                # Mark all tasks complete
                for todo in st.session_state.todos:
                    todo["status"] = "complete"
                
                # Store research steps in session state for display
                st.session_state.research_steps = research_steps
                
                # Build final report from the accepted final answer
                # Look for FINAL_ANSWER_ACCEPTED in search_results (tool outputs)
                accepted_answer = None
                for result in search_results:
                    if 'FINAL_ANSWER_ACCEPTED' in result and '---ANSWER---' in result:
                        accepted_answer = result.split('---ANSWER---')[1].strip()
                        break
                
                # Fall back to final_answer variable or longest content
                if accepted_answer:
                    final_answer = accepted_answer
                elif final_answer is None and all_content:
                    # Find the longest content as the likely final answer
                    final_answer = max(all_content, key=len) if all_content else "No answer generated."
                
                # Always build a report, even if answer wasn't formally accepted
                if final_answer is None:
                    final_answer = "Research completed but no final answer was generated. Check the event log for details."
                
                if final_answer:
                    # Build comprehensive report
                    report = f"# Research Report\n\n"
                    report += f"**Query:** {st.session_state.research_query}\n\n"
                    report += f"**Research Stats:** {search_count} searches, {think_count} reflections\n\n"
                    report += f"## Answer\n\n{final_answer}\n\n"
                    
                    if search_results:
                        # Extract URLs from search results (excluding the final answer result)
                        urls_found = []
                        for result in search_results:
                            if "URL:" in result and 'FINAL_ANSWER_ACCEPTED' not in result:
                                for line in result.split('\n'):
                                    if 'URL:' in line:
                                        urls_found.append(line.strip())
                        if urls_found:
                            report += f"## Sources Consulted ({len(urls_found)} URLs found)\n\n"
                            for i, url in enumerate(urls_found[:15], 1):
                                report += f"{i}. {url}\n"
                    
                    st.session_state.final_report = report
                    st.success(f"‚úÖ Research complete! {search_count} searches, {think_count} reflections.")
                else:
                    st.session_state.final_report = "No final answer was generated. The agent may not have used submit_final_answer tool properly."
                    st.warning("‚ö†Ô∏è No final answer captured. The agent should use submit_final_answer tool.")
                
                # Mark as complete
                st.session_state.current_phase = "complete"
                status.update(label="‚úÖ Research Complete!", state="complete", expanded=False)
                break  # Success - exit retry loop
                
            except Exception as e:
                error_msg = str(e)
                if "empty" in error_msg.lower() and retry_count < max_retries - 1:
                    retry_count += 1
                    st.warning(f"‚ö†Ô∏è Model returned empty response, retrying ({retry_count}/{max_retries})...")
                    continue
                else:
                    st.error(f"Error during research: {error_msg}")
                    import traceback
                    st.code(traceback.format_exc())
                    st.session_state.current_phase = "complete"  # Still transition to show what we have
                    status.update(label="‚ùå Research Failed", state="error", expanded=True)
                    break
        
        # Only rerun if we successfully transitioned to complete phase
        if st.session_state.current_phase == "complete":
            st.rerun()


def render_completion_phase():
    """Render the results and final report."""
    st.markdown("## üìä Research Results")
    
    # Show the original query
    st.markdown(f"**Query:** {st.session_state.research_query}")
    
    # Max iterations warning
    if st.session_state.max_iterations_reached:
        st.warning("‚ö†Ô∏è **Note:** Maximum iterations were reached during research. Results may be incomplete.")
    
    st.divider()
    
    # Display final report prominently
    if st.session_state.final_report:
        st.markdown(st.session_state.final_report)
    elif "/final_report.md" in st.session_state.agent_files:
        st.markdown(st.session_state.agent_files["/final_report.md"])
    else:
        st.error("‚ùå No final report was generated.")
        st.info("The agent may not have completed properly. Check the progress history below for details.")
    
    st.divider()
    
    # Research statistics
    search_steps = [s for s in st.session_state.research_steps if s["type"] == "search"]
    reflection_steps = [s for s in st.session_state.research_steps if s["type"] == "reflection"]
    
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total Steps", st.session_state.iteration_count)
    with col2:
        st.metric("Searches", len(search_steps))
    with col3:
        st.metric("Reflections", len(reflection_steps))
    
    # Research work in progress - Searches
    if search_steps:
        with st.expander(f"üîç Web Searches ({len(search_steps)})", expanded=True):
            for i, step in enumerate(search_steps, 1):
                with st.expander(f"Search {i}: {step['query'][:60]}{'...' if len(step['query']) > 60 else ''}", expanded=False):
                    st.markdown(f"**Query:** {step['query']}")
                    if step.get('result'):
                        st.markdown("**Results:**")
                        # Parse and display results nicely
                        result = step['result']
                        # Extract title and URL if present
                        if 'Title:' in result and 'URL:' in result:
                            lines = result.split('\n')
                            for line in lines:
                                if line.startswith('Title:'):
                                    st.markdown(f"üìÑ **{line.replace('Title:', '').strip()}**")
                                elif line.startswith('URL:'):
                                    url = line.replace('URL:', '').strip()
                                    st.markdown(f"üîó [{url}]({url})")
                                elif line.startswith('Content:'):
                                    content = line.replace('Content:', '').strip()
                                    st.caption(content[:500] + "..." if len(content) > 500 else content)
                        else:
                            st.caption(result[:800] + "..." if len(result) > 800 else result)
                    else:
                        st.caption("No results captured")
    
    # Research work in progress - Reflections
    if reflection_steps:
        with st.expander(f"üß† Agent Reflections ({len(reflection_steps)})", expanded=False):
            for i, step in enumerate(reflection_steps, 1):
                with st.expander(f"Reflection {i}", expanded=False):
                    st.markdown(step.get('content', 'No content'))
    
    # Raw progress history (collapsed by default)
    with st.expander("üìú Raw Progress History", expanded=False):
        if st.session_state.step_history:
            for i, step in enumerate(st.session_state.step_history):
                if step:
                    step_name = step.get('name', 'Unknown')
                    step_desc = step.get('description', '')[:100]
                    st.markdown(f"**Step {i+1}:** {step_name}")
                    if step_desc:
                        st.caption(step_desc)
        else:
            st.info("No step history recorded.")
    
    # Display agent files if any
    if st.session_state.agent_files:
        with st.expander("üìÅ Agent Files", expanded=False):
            for filename, content in st.session_state.agent_files.items():
                st.markdown(f"**{filename}**")
                st.code(content[:1000] if len(content) > 1000 else content, language="markdown")
    
    st.divider()
    
    # Action buttons
    col1, col2 = st.columns(2)
    with col1:
        if st.session_state.final_report:
            st.download_button(
                "üì• Download Report",
                data=st.session_state.final_report,
                file_name="research_report.md",
                mime="text/markdown"
            )
    with col2:
        if st.button("üîÑ New Research"):
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.rerun()


def main():
    """Main application entry point."""
    initialize_session_state()
    render_sidebar()
    
    st.title("üîç Local Deep Researcher")
    st.caption("Powered by LangChain DeepAgents + Ollama")
    
    # Phase routing
    if st.session_state.current_phase == "input":
        render_input_phase()
    elif st.session_state.current_phase == "research":
        render_research_phase()
    elif st.session_state.current_phase == "complete":
        render_completion_phase()


if __name__ == "__main__":
    main()
