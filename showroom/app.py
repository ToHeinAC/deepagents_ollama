# Generated by Antigravity [Forge: Gemini 3.0] | Spec: [Architect: Opus 4.5]
"""Deep Researcher Streamlit Application.

A web interface for the local deep researcher using LangChain's deepagents framework.
Features real-time task tracking, step visualization, and quality monitoring.

Run with: streamlit run app.py --server.port 8508
"""

import streamlit as st
import os
import sys
import time
from datetime import datetime
from typing import Dict, Any, Optional
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Add current directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from agent import get_agent, get_agent_config

# Page configuration
st.set_page_config(
    page_title="Deep Researcher v0.1",
    page_icon="ğŸ”",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better UI
st.markdown("""
<style>
    .stProgress > div > div > div > div {
        background-color: #4CAF50;
    }
    .step-indicator {
        padding: 10px;
        border-radius: 5px;
        margin: 5px 0;
    }
    .step-current {
        background-color: #2196F3;
        color: white;
    }
    .step-complete {
        background-color: #4CAF50;
        color: white;
    }
    .step-pending {
        background-color: #9E9E9E;
        color: white;
    }
    .warning-banner {
        background-color: #FF9800;
        color: white;
        padding: 15px;
        border-radius: 5px;
        margin: 10px 0;
    }
</style>
""", unsafe_allow_html=True)


def initialize_session_state():
    """Initialize all session state variables."""
    if "messages" not in st.session_state:
        st.session_state.messages = []
    
    if "current_phase" not in st.session_state:
        st.session_state.current_phase = "input"  # input, research, complete
    
    if "research_query" not in st.session_state:
        st.session_state.research_query = None
    
    if "todos" not in st.session_state:
        st.session_state.todos = []
    
    if "current_step" not in st.session_state:
        st.session_state.current_step = None
    
    if "step_history" not in st.session_state:
        st.session_state.step_history = []
    
    if "iteration_count" not in st.session_state:
        st.session_state.iteration_count = 0
    
    if "max_iterations_reached" not in st.session_state:
        st.session_state.max_iterations_reached = False
    
    if "final_report" not in st.session_state:
        st.session_state.final_report = None
    
    if "agent_files" not in st.session_state:
        st.session_state.agent_files = {}
    
    if "subagent_activity" not in st.session_state:
        st.session_state.subagent_activity = []


def render_sidebar():
    """Render the sidebar with configuration and debug info."""
    with st.sidebar:
        st.title("âš™ï¸ Configuration")
        
        config = get_agent_config()
        
        st.subheader("Model Settings")
        st.info(f"**Model:** {config['model']}")
        st.caption(f"Base URL: {config['base_url']}")
        
        st.divider()
        
        st.subheader("Agent Limits")
        st.metric("Max Concurrent Sub-Agents", config['max_concurrent_research_units'])
        st.metric("Max Research Iterations", config['max_researcher_iterations'])
        st.metric("Recursion Limit", config['recursion_limit'])
        
        st.divider()
        
        st.subheader("Current Session")
        st.metric("Phase", st.session_state.current_phase.upper())
        st.metric("Iteration Count", st.session_state.iteration_count)
        
        if st.session_state.max_iterations_reached:
            st.warning("âš ï¸ Max iterations reached!")
        
        st.divider()
        
        # Debug section
        if st.checkbox("ğŸ”§ Show Debug Info"):
            st.json({
                "todos": st.session_state.todos,
                "current_step": st.session_state.current_step,
                "step_history_count": len(st.session_state.step_history),
                "subagent_activity_count": len(st.session_state.subagent_activity),
                "agent_files": list(st.session_state.agent_files.keys()),
            })
        
        if st.button("ğŸ”„ Reset Session"):
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.rerun()


def render_task_tracker():
    """Render the to-do list and task tracking panel."""
    st.subheader("ğŸ“‹ Research Tasks")
    
    if not st.session_state.todos:
        st.info("No tasks created yet. The agent will create a task list when research begins.")
        return
    
    for i, todo in enumerate(st.session_state.todos):
        status = todo.get("status", "pending")
        title = todo.get("title", f"Task {i+1}")
        
        if status == "complete":
            st.markdown(f"âœ… ~~{title}~~")
        elif status == "in_progress":
            st.markdown(f"ğŸ”„ **{title}** _(in progress)_")
        else:
            st.markdown(f"â³ {title}")


def render_step_indicator():
    """Render current and previous step indicators."""
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("ğŸ¯ Current Step")
        if st.session_state.current_step:
            st.markdown(f"""
            <div class="step-indicator step-current">
                <strong>{st.session_state.current_step.get('name', 'Processing...')}</strong>
                <br><small>{st.session_state.current_step.get('description', '')}</small>
            </div>
            """, unsafe_allow_html=True)
        else:
            st.info("Waiting for agent to start...")
    
    with col2:
        st.subheader("ğŸ“œ Previous Steps")
        if st.session_state.step_history:
            # Show last 3 steps
            for step in reversed(st.session_state.step_history[-3:]):
                st.markdown(f"""
                <div class="step-indicator step-complete">
                    âœ“ {step.get('name', 'Completed step')}
                </div>
                """, unsafe_allow_html=True)
        else:
            st.info("No completed steps yet.")


def render_subagent_activity():
    """Render sub-agent spawning and activity."""
    if st.session_state.subagent_activity:
        with st.expander("ğŸ¤– Sub-Agent Activity", expanded=True):
            for activity in st.session_state.subagent_activity[-5:]:  # Show last 5
                agent_name = activity.get("agent", "Unknown")
                action = activity.get("action", "running")
                query = activity.get("query", "")
                
                if action == "spawned":
                    st.markdown(f"ğŸš€ **{agent_name}** spawned: _{query[:100]}..._" if len(query) > 100 else f"ğŸš€ **{agent_name}** spawned: _{query}_")
                elif action == "completed":
                    st.markdown(f"âœ… **{agent_name}** completed")
                else:
                    st.markdown(f"ğŸ”„ **{agent_name}**: {action}")


def render_input_phase():
    """Render the query input phase."""
    st.markdown("## ğŸ” Deep Research")
    st.markdown("Ask any research question and the deep agent will analyze, research, and synthesize a comprehensive report.")
    
    # Query input
    query = st.chat_input("What would you like to research?")
    
    if query:
        st.session_state.research_query = query
        st.session_state.messages.append({"role": "user", "content": query})
        st.session_state.current_phase = "research"
        st.rerun()
    
    # Display previous messages if any
    for msg in st.session_state.messages:
        with st.chat_message(msg["role"]):
            st.markdown(msg["content"])


def process_agent_event(event: Dict[str, Any]):
    """Process a streaming event from the agent and update UI state."""
    for key, value in event.items():
        # Track todos
        if key == "write_todos" or "todos" in str(value).lower():
            if isinstance(value, dict) and "todos" in value:
                st.session_state.todos = value["todos"]
        
        # Track file writes
        if key == "write_file" or "file" in str(key).lower():
            if isinstance(value, dict):
                filename = value.get("filename", value.get("path", "unknown"))
                content = value.get("content", "")
                st.session_state.agent_files[filename] = content
                
                # Check for final report
                if "final_report" in filename.lower():
                    st.session_state.final_report = content
        
        # Track sub-agent spawning
        if key == "task" or "subagent" in str(key).lower():
            st.session_state.subagent_activity.append({
                "agent": value.get("agent_name", "research-agent"),
                "action": "spawned",
                "query": str(value.get("input", ""))[:200],
                "timestamp": datetime.now().isoformat(),
            })
        
        # Update current step
        st.session_state.step_history.append(st.session_state.current_step or {})
        st.session_state.current_step = {
            "name": key,
            "description": str(value)[:100] if value else "",
            "timestamp": datetime.now().isoformat(),
        }
        
        # Track iterations
        st.session_state.iteration_count += 1
        
        # Check max iterations
        config = get_agent_config()
        max_iter = config["recursion_limit"]
        if st.session_state.iteration_count >= max_iter:
            st.session_state.max_iterations_reached = True


def render_research_phase():
    """Render the research execution phase."""
    st.markdown(f"## ğŸ”¬ Researching: _{st.session_state.research_query}_")
    
    # Layout: main content and sidebar panels
    main_col, side_col = st.columns([2, 1])
    
    with side_col:
        render_task_tracker()
        st.divider()
        render_subagent_activity()
    
    with main_col:
        render_step_indicator()
        
        # Max iterations warning
        if st.session_state.max_iterations_reached:
            st.markdown("""
            <div class="warning-banner">
                âš ï¸ <strong>Maximum iterations reached!</strong><br>
                The research was stopped to prevent infinite loops. 
                The quality of results may be affected.
            </div>
            """, unsafe_allow_html=True)
        
        st.divider()
        
        # Start research button
        if st.button("ğŸš€ Start Research", type="primary", disabled=st.session_state.iteration_count > 0):
            run_research()


def run_research():
    """Execute the deep research agent."""
    agent = get_agent()
    query = st.session_state.research_query
    config = get_agent_config()
    
    with st.status("ğŸ” Deep Research in Progress...", expanded=True) as status:
        st.write("Initializing agent...")
        st.write(f"â³ Using model: **{config['model']}** (may take 30-60 seconds per step)")
        
        # Create a placeholder for live updates
        progress_placeholder = st.empty()
        event_log = st.expander("ğŸ“Š Event Log (Debug)", expanded=False)
        
        # Initial state matching AgentState TypedDict
        initial_state = {
            "messages": [("human", query)],
            "research_findings": [],
            "iteration_count": 0
        }
        
        max_retries = 3
        retry_count = 0
        
        # Auto-generate initial task list
        st.session_state.todos = [
            {"title": "Analyze research question", "status": "in_progress"},
            {"title": "Search for information", "status": "pending"},
            {"title": "Reflect on findings", "status": "pending"},
            {"title": "Synthesize final answer", "status": "pending"},
        ]
        
        while retry_count < max_retries:
            try:
                event_count = 0
                all_content = []  # Collect all content for final report
                search_results = []  # Track search results
                
                # Stream agent execution
                for event in agent.stream(initial_state):
                    event_count += 1
                    
                    # Log all events for debugging
                    with event_log:
                        st.write(f"Event {event_count}: {list(event.keys())}")
                    
                    # Process different event types
                    for key, value in event.items():
                        # Update progress display
                        progress_placeholder.info(f"ğŸ”„ Step {event_count}: {key}")
                        
                        # Handle agent node output
                        if key == "agent" and isinstance(value, dict):
                            messages = value.get("messages", [])
                            for msg in messages:
                                # Capture content for final report
                                if hasattr(msg, 'content') and msg.content:
                                    content = str(msg.content)
                                    all_content.append(content)
                                    st.write(f"ğŸ’¬ {content[:500]}...")
                                    
                                    # Update task: analyzing complete
                                    if st.session_state.todos[0]["status"] == "in_progress":
                                        st.session_state.todos[0]["status"] = "complete"
                                
                                if hasattr(msg, 'tool_calls') and msg.tool_calls:
                                    for tc in msg.tool_calls:
                                        tool_name = tc.get('name', 'unknown')
                                        tool_args = tc.get('args', {})
                                        st.write(f"ğŸ”§ Tool: **{tool_name}**")
                                        
                                        # Track tavily search
                                        if tool_name == "tavily_search":
                                            query = tool_args.get('query', '')
                                            st.write(f"ğŸ” Searching: {query}")
                                            # Update task: searching
                                            st.session_state.todos[1]["status"] = "in_progress"
                                        
                                        # Track think tool
                                        if tool_name == "think_tool":
                                            st.write(f"ğŸ§  Reflecting...")
                                            # Update task: reflecting
                                            st.session_state.todos[1]["status"] = "complete"
                                            st.session_state.todos[2]["status"] = "in_progress"
                        
                        # Handle tools node output
                        if key == "tools" and isinstance(value, dict):
                            messages = value.get("messages", [])
                            for msg in messages:
                                if hasattr(msg, 'content') and msg.content:
                                    content_preview = str(msg.content)[:300]
                                    st.write(f"ğŸ“„ Result: {content_preview}...")
                                    search_results.append(str(msg.content))
                        
                        # Update step tracking
                        st.session_state.step_history.append(st.session_state.current_step or {})
                        st.session_state.current_step = {
                            "name": key,
                            "description": str(value)[:100] if value else "",
                            "timestamp": datetime.now().isoformat(),
                        }
                        st.session_state.iteration_count += 1
                    
                    # Check max iterations
                    if st.session_state.iteration_count >= config["recursion_limit"]:
                        st.session_state.max_iterations_reached = True
                        st.warning("Maximum iterations reached, stopping...")
                        break
                
                # Mark all tasks complete
                for todo in st.session_state.todos:
                    todo["status"] = "complete"
                
                # Build final report from all captured content
                if all_content:
                    # Use the last substantial content as the final report
                    final_answer = all_content[-1] if all_content else "No answer generated."
                    
                    # Build comprehensive report
                    report = f"# Research Report\n\n"
                    report += f"**Query:** {query}\n\n"
                    report += f"## Answer\n\n{final_answer}\n\n"
                    
                    if search_results:
                        report += f"## Sources Consulted\n\n"
                        for i, result in enumerate(search_results[:3], 1):
                            # Extract just the URL if present
                            if "URL:" in result:
                                url_line = [l for l in result.split('\n') if 'URL:' in l]
                                if url_line:
                                    report += f"{i}. {url_line[0]}\n"
                    
                    st.session_state.final_report = report
                
                # Mark as complete
                st.session_state.current_phase = "complete"
                status.update(label="âœ… Research Complete!", state="complete", expanded=False)
                break  # Success - exit retry loop
                
            except Exception as e:
                error_msg = str(e)
                if "empty" in error_msg.lower() and retry_count < max_retries - 1:
                    retry_count += 1
                    st.warning(f"âš ï¸ Model returned empty response, retrying ({retry_count}/{max_retries})...")
                    continue
                else:
                    st.error(f"Error during research: {error_msg}")
                    import traceback
                    st.code(traceback.format_exc())
                    status.update(label="âŒ Research Failed", state="error", expanded=True)
                    break
        
        st.rerun()


def render_completion_phase():
    """Render the results and final report."""
    st.markdown("## ğŸ“Š Research Results")
    
    # Max iterations warning
    if st.session_state.max_iterations_reached:
        st.warning("âš ï¸ **Note:** Maximum iterations were reached during research. Results may be incomplete.")
    
    # Display final report
    if st.session_state.final_report:
        st.markdown("### ğŸ“„ Final Report")
        st.markdown(st.session_state.final_report)
    elif "/final_report.md" in st.session_state.agent_files:
        st.markdown("### ğŸ“„ Final Report")
        st.markdown(st.session_state.agent_files["/final_report.md"])
    else:
        st.info("No final report was generated. Check the agent files below.")
    
    st.divider()
    
    # Display agent files
    if st.session_state.agent_files:
        with st.expander("ğŸ“ Agent Files"):
            for filename, content in st.session_state.agent_files.items():
                st.markdown(f"**{filename}**")
                st.code(content[:1000] if len(content) > 1000 else content, language="markdown")
    
    # Research statistics
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total Steps", st.session_state.iteration_count)
    with col2:
        st.metric("Tasks Completed", len([t for t in st.session_state.todos if t.get("status") == "complete"]))
    with col3:
        st.metric("Sub-Agents Used", len(st.session_state.subagent_activity))
    
    st.divider()
    
    # Action buttons
    col1, col2 = st.columns(2)
    with col1:
        if st.session_state.final_report:
            st.download_button(
                "ğŸ“¥ Download Report",
                data=st.session_state.final_report,
                file_name="research_report.md",
                mime="text/markdown"
            )
    with col2:
        if st.button("ğŸ”„ New Research"):
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.rerun()


def main():
    """Main application entry point."""
    initialize_session_state()
    render_sidebar()
    
    st.title("ğŸ” Local Deep Researcher")
    st.caption("Powered by LangChain DeepAgents + Ollama")
    
    # Phase routing
    if st.session_state.current_phase == "input":
        render_input_phase()
    elif st.session_state.current_phase == "research":
        render_research_phase()
    elif st.session_state.current_phase == "complete":
        render_completion_phase()


if __name__ == "__main__":
    main()
